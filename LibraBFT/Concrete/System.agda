{- Byzantine Fault Tolerant Consensus Verification in Agda, version 0.9.

   Copyright (c) 2020, 2021, Oracle and/or its affiliates.
   Licensed under the Universal Permissive License v 1.0 as shown at https://opensource.oracle.com/licenses/upl
-}
open import Optics.All
open import LibraBFT.Prelude
open import LibraBFT.Hash
open import LibraBFT.Lemmas
open import LibraBFT.Base.KVMap
open import LibraBFT.Base.PKCS
open import LibraBFT.Base.Types
open import LibraBFT.Impl.Base.Types
open import LibraBFT.Impl.Consensus.Types
open import LibraBFT.Impl.Util.Crypto
open import LibraBFT.Impl.Handle sha256 sha256-cr
open import LibraBFT.Concrete.System.Parameters
open        EpochConfig

-- This module defines an abstract system state given a reachable
-- concrete system state.

module LibraBFT.Concrete.System where

 ‚Ñì-VSFP : Level
 ‚Ñì-VSFP = 1‚Ñì ‚Ñì‚äî ‚Ñì-RoundManagerAndMeta

 open import LibraBFT.Yasm.Base
 import      LibraBFT.Yasm.System ‚Ñì-RoundManagerAndMeta ‚Ñì-VSFP ConcSysParms as LYS
 open import LibraBFT.Abstract.Util.AvailableEpochs NodeId ‚Ñì-EC EpochConfig epochId renaming (lookup'' to AE-lookup)

 -- A peer pid can sign a new message for a given PK if pid is the owner of a PK in an EpochConfig
 -- it knows about.  Note that only honest steps update a peer's state, and we will prove that the
 -- EpochConfigs known about by different peers are the same (everyone has the same initial
 -- EpochConfig for now, and later we will add EpochConfigs only by committing epoch-changing
 -- transactions.
 record PeerCanSignForPK (rmam : RoundManagerAndMeta) (v : Vote) (pid : NodeId) (pk : PK) : Set ‚Ñì-VSFP where
   constructor mkPCS4PK
   field
     eInRange : v ^‚àô vEpoch < ‚ÇãrmamMetaNumEpochs rmam
     ùìî        : EpochConfig
     ùìî‚â°       : ùìî ‚â° AE-lookup (‚ÇãrmamMetaAvailEpochs rmam) eInRange
     mbr      : Member ùìî
     nid‚â°     : toNodeId  ùìî mbr ‚â° pid
     pk‚â°      : getPubKey ùìî mbr ‚â° pk
 open PeerCanSignForPK

 PCS4PK‚áíNodeId-PK-OK : ‚àÄ {rmam v pid pk} ‚Üí (pcs : PeerCanSignForPK rmam v pid pk) ‚Üí NodeId-PK-OK (ùìî pcs) pk pid
 PCS4PK‚áíNodeId-PK-OK (mkPCS4PK _ _ _ mbr n‚â° pk‚â°) = mbr , n‚â° , pk‚â°

 postulate -- TODO-1: Eliminate bogus placeholders These are bogus placeholders representing the
   -- fact that we don't yet add any EpochConfigs after initialization.  TODO-1: more specific (and
   -- true!) properties should now be provable to enable a real proof of PeerCanSignForPK-stable.
   -- Note that the handler does not change the number of EpochConfigs or available EpochConfigs
   -- yet; this will become more challenging in future when we model epoch changes.  One easy
   -- property noEpochChangeSPS is proved below.
   PeerCanSignForPKBogus1 : ‚àÄ {rmam1 rmam2 : RoundManagerAndMeta}
                        ‚Üí ‚ÇãrmamMetaNumEpochs rmam2 ‚â° ‚ÇãrmamMetaNumEpochs rmam1

   PeerCanSignForPKBogus2 : ‚àÄ {rmam1 rmam2 : RoundManagerAndMeta}
                        ‚Üí (numùìîs‚â° : ‚ÇãrmamMetaNumEpochs rmam2 ‚â° ‚ÇãrmamMetaNumEpochs rmam1)
                        ‚Üí ‚ÇãrmamMetaAvailEpochs rmam1 ‚â° subst AvailableEpochs numùìîs‚â° (‚ÇãrmamMetaAvailEpochs rmam2)

 PeerCanSignForPKAux : ‚àÄ {rmam1 rmam2 : RoundManagerAndMeta}{v pid pk}
                     ‚Üí PeerCanSignForPK rmam1 v pid pk
                     ‚Üí (numùìîs‚â° : ‚ÇãrmamMetaNumEpochs rmam2 ‚â° ‚ÇãrmamMetaNumEpochs rmam1)
                     ‚Üí ‚ÇãrmamMetaAvailEpochs rmam1 ‚â° subst AvailableEpochs numùìîs‚â° (‚ÇãrmamMetaAvailEpochs rmam2)
                     ‚Üí PeerCanSignForPK rmam2 v pid pk
 PeerCanSignForPKAux (mkPCS4PK eInRange ùìî ùìî‚â° mbr nid‚â° pk‚â°) refl refl = mkPCS4PK eInRange ùìî ùìî‚â° mbr nid‚â° pk‚â°

 -- Not yet used; see TODO comment above
 noEpochChangeSPS : ‚àÄ {st pid ps' msgs}
                  ‚Üí LYS.initialised st pid ‚â° LYS.initd
                  ‚Üí LYS.StepPeerState pid (LYS.msgPool st) (LYS.initialised st) (LYS.peerStates st pid) (ps' , msgs)
                  ‚Üí ‚ÇãrmamMetaNumEpochs (LYS.peerStates st pid) ‚â° ‚ÇãrmamMetaNumEpochs ps'
 noEpochChangeSPS ini (LYS.step-init uni) = ‚ä•-elim (LYS.uninitd‚â¢initd (trans (sym uni) ini))
 noEpochChangeSPS _ (LYS.step-msg {_ , P x} m‚ààpool ini) = refl
 noEpochChangeSPS _ (LYS.step-msg {_ , V x} m‚ààpool ini) = refl
 noEpochChangeSPS _ (LYS.step-msg {_ , C x} m‚ààpool ini) = refl

 PeerCanSignForPK-stable : LYS.ValidSenderForPK-stable-type PeerCanSignForPK
 PeerCanSignForPK-stable {st} {pid = pid} r (LYS.step-init uni) ini _ = ‚ä•-elim (LYS.uninitd‚â¢initd (trans (sym uni) ini))
 PeerCanSignForPK-stable {st} {v} {pk} {pid = pid} r (LYS.step-msg {m} m‚ààpool _) ini pcs = PeerCanSignForPKAux
                                                                                          {LYS.peerStates st pid}
                                                                                          {proj‚ÇÅ (peerStep pid (proj‚ÇÇ m) 0 (LYS.peerStates st pid))}
                                                                                          {v} {pid} {pk}
                                                                                          pcs
                                                                                          (PeerCanSignForPKBogus1
                                                                                             {LYS.peerStates st pid}
                                                                                             {proj‚ÇÅ (peerStep pid (proj‚ÇÇ m) 0 (LYS.peerStates st pid))})
                                                                                          (PeerCanSignForPKBogus2
                                                                                             {LYS.peerStates st pid}
                                                                                             {proj‚ÇÅ (peerStep pid (proj‚ÇÇ m) 0 (LYS.peerStates st pid))}
                                                                                             PeerCanSignForPKBogus1)

 open import LibraBFT.Yasm.Yasm ‚Ñì-RoundManagerAndMeta ‚Ñì-VSFP ConcSysParms PeerCanSignForPK
                                                                           (Œª {st} {part} {pk} ‚Üí PeerCanSignForPK-stable {st} {part} {pk})

 -- An implementation must prove that, if one of its handlers sends a
 -- message that contains a vote and is signed by a public key pk, then
 -- either the vote's author is the peer executing the handler, the
 -- epochId is in range, the peer is a member of the epoch, and its key
 -- in that epoch is pk; or, a message with the same signature has been
 -- sent before.  This is represented by StepPeerState-AllValidParts.
 module WithSPS (sps-corr : StepPeerState-AllValidParts) where

   -- Bring in 'unwind', 'ext-unforgeability' and friends
   open Structural sps-corr

   -- TODO-1: refactor this somewhere else?  Maybe something like
   -- LibraBFT.Impl.Consensus.Types.Properties?
   sameHonestSig‚áísameVoteData : ‚àÄ {v1 v2 : Vote} {pk}
                              ‚Üí Meta-Honest-PK pk
                              ‚Üí WithVerSig pk v1
                              ‚Üí WithVerSig pk v2
                              ‚Üí v1 ^‚àô vSignature ‚â° v2 ^‚àô vSignature
                              ‚Üí NonInjective-‚â° sha256 ‚äé v2 ^‚àô vVoteData ‚â° v1 ^‚àô vVoteData
   sameHonestSig‚áísameVoteData {v1} {v2} hpk wvs1 wvs2 refl
      with verify-bs-inj (verified wvs1) (verified wvs2)
        -- The signable fields of the votes must be the same (we do not model signature collisions)
   ...| bs‚â°
        -- Therefore the LedgerInfo is the same for the new vote as for the previous vote
        = sym <‚äé$> (hashVote-inj1 {v1} {v2} (sameBS‚áísameHash bs‚â°))

   -- We are now ready to define an 'IntermediateSystemState' view for a concrete
   -- reachable state.  We will do so by fixing an epoch that exists in
   -- the system, which will enable us to define the abstract
   -- properties. The culminaton of this 'PerEpoch' module is seen in
   -- the 'IntSystemState' "function" at the bottom, which probably the
   -- best place to start uynderstanding this.  Longer term, we will
   -- also need higher-level, cross-epoch properties.
   module PerState (st : SystemState)(r : ReachableSystemState st) where

    -- TODO-3: Remove this postulate when we are satisfied with the
    -- "hash-collision-tracking" solution. For example, when proving voo
    -- (in LibraBFT.LibraBFT.Concrete.Properties.VotesOnce), we
    -- currently use this postulate to eliminate the possibility of two
    -- votes that have the same signature but different VoteData
    -- whenever we use sameHonestSig‚áísameVoteData.  To eliminate the
    -- postulate, we need to refine the properties we prove to enable
    -- the possibility of a hash collision, in which case the required
    -- property might not hold.  However, it is not sufficient to simply
    -- prove that a hash collision *exists* (which is obvious,
    -- regardless of the LibraBFT implementation).  Rather, we
    -- ultimately need to produce a specific hash collision and relate
    -- it to the data in the system, so that we can prove that the
    -- desired properties hold *unless* an actual hash collision is
    -- found by the implementation given the data in the system.  In
    -- the meantime, we simply require that the collision identifies a
    -- reachable state; later "collision tracking" will require proof
    -- that the colliding values actually exist in that state.
    postulate  -- temporary assumption that hash collisions don't exist (see comment above)
      meta-sha256-cr : ¬¨ (NonInjective-‚â° sha256)

    module PerEpoch (ùìî : EpochConfig) where

     open import LibraBFT.Abstract.Abstract     UID _‚âüUID_ NodeId ùìî (ConcreteVoteEvidence ùìî) as Abs hiding (qcVotes; Vote)
     open import LibraBFT.Concrete.Intermediate                   ùìî (ConcreteVoteEvidence ùìî)
     open import LibraBFT.Concrete.Records                        ùìî

     -- * Auxiliary definitions;
     -- Here we capture the idea that there exists a vote message that
     -- witnesses the existence of a given Abs.Vote
     record ‚àÉVoteMsgFor (v : Abs.Vote) : Set where
       constructor mk‚àÉVoteMsgFor
       field
         -- A message that was actually sent
         nm            : NetworkMsg
         cv            : Vote
         cv‚àànm         : cv ‚äÇMsg nm
         -- And contained a valid vote that, once abstracted, yeilds v.
         vmsgMember    : EpochConfig.Member ùìî
         vmsgSigned    : WithVerSig (getPubKey ùìî vmsgMember) cv
         vmsg‚âàv        : Œ±-ValidVote ùìî cv vmsgMember ‚â° v
         vmsgEpoch     : cv ^‚àô vEpoch ‚â° epochId ùìî
     open ‚àÉVoteMsgFor public

     record ‚àÉVoteMsgSentFor (sm : SentMessages)(v : Abs.Vote) : Set where
       constructor mk‚àÉVoteMsgSentFor
       field
         vmFor        : ‚àÉVoteMsgFor v
         vmSender     : NodeId
         nmSentByAuth : (vmSender , (nm vmFor)) ‚àà sm
     open ‚àÉVoteMsgSentFor public

     ‚àÉVoteMsgSentFor-stable : ‚àÄ {pre : SystemState} {post : SystemState} {v}
                            ‚Üí Step pre post
                            ‚Üí ‚àÉVoteMsgSentFor (msgPool pre) v
                            ‚Üí ‚àÉVoteMsgSentFor (msgPool post) v
     ‚àÉVoteMsgSentFor-stable theStep (mk‚àÉVoteMsgSentFor sndr vmFor sba) =
                                     mk‚àÉVoteMsgSentFor sndr vmFor (msgs-stable theStep sba)

     record ‚àÉVoteMsgInFor (outs : List NetworkMsg)(v : Abs.Vote) : Set where
       constructor mk‚àÉVoteMsgInFor
       field
         vmFor    : ‚àÉVoteMsgFor v
         nmInOuts : nm vmFor ‚àà outs
     open ‚àÉVoteMsgInFor public

     ‚ààQC‚áísent : ‚àÄ{st : SystemState} {q Œ±}
              ‚Üí Abs.Q q Œ±-Sent (msgPool st)
              ‚Üí Meta-Honest-Member Œ±
              ‚Üí (vŒ± : Œ± Abs.‚ààQC q)
              ‚Üí ‚àÉVoteMsgSentFor (msgPool st) (Abs.‚ààQC-Vote q vŒ±)
     ‚ààQC‚áísent {e} {st} {Œ± = Œ±} vsent@(ws {sender} {nm} e‚â° nm‚ààst (qc‚ààNM {cqc} {q} .{nm} valid cqc‚àànm q‚â°)) ha va
       with All-reduce‚Åª {vdq = Any-lookup va} (Œ±-Vote cqc valid) All-self
                        (subst (Any-lookup va ‚àà_) (cong Abs.qVotes q‚â°) (Any-lookup-correctP va))
     ...| as , as‚ààcqc , Œ±‚â°
       with  Œ±-Vote-evidence cqc valid  as‚ààcqc | inspect
            (Œ±-Vote-evidence cqc valid) as‚ààcqc
     ...| ev | [ refl ]
        with vote‚ààqc {vs = as} as‚ààcqc refl cqc‚àànm
     ...| v‚àànm =
          mk‚àÉVoteMsgSentFor
                   (mk‚àÉVoteMsgFor nm (‚ÇãcveVote ev) v‚àànm
                                  (‚ÇãivvMember (‚ÇãcveIsValidVote ev))
                                  (‚ÇãivvSigned (‚ÇãcveIsValidVote ev)) (sym Œ±‚â°)
                                  (‚ÇãivvEpoch (‚ÇãcveIsValidVote ev)))
                   sender
                   nm‚ààst

     -- Finally, we can define the abstract system state corresponding to the concrete state st
     IntSystemState : IntermediateSystemState ‚Ñì0
     IntSystemState = record
       { InSys           = Œª { r ‚Üí r Œ±-Sent (msgPool st) }
       ; HasBeenSent     = Œª { v ‚Üí ‚àÉVoteMsgSentFor (msgPool st) v }
       ; ‚ààQC‚áíHasBeenSent = ‚ààQC‚áísent {st = st}
       }
